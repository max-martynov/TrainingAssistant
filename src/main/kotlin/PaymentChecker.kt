import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.withContext
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.json.Json
import java.lang.management.ManagementFactory


class PaymentChecker(
    private val clientsRepository: ClientsRepository,
    private val vKApiClient: VKApiClient
) {

    suspend fun checkPayment(notification: String) = coroutineScope {
        val messageEvent = Json { ignoreUnknownKeys = true }.decodeFromString<Event>(notification).messageEvent
        val client = clientsRepository.findById(messageEvent.userId) ?: return@coroutineScope
        if (client.status != Status.WAITING_FOR_PAYMENT) {
            vKApiClient.sendMessageEventAnswer(messageEvent, getShowSnackbarString("–û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ. –•–æ—Ä–æ—à–∏—Ö —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫!"))
        } else if (QiwiAPI.isPaid(client.billId)) {
            async { confirmPayment(client, messageEvent) }
            if (client.trial)
                async { sendMainKeyboardWithPromocodes(client.id) }
            // TODO - process other states and send appropriate message
        } else {
            vKApiClient.sendMessageEventAnswer(
                messageEvent,
                getShowSnackbarString("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –¥–∞–Ω–Ω—ã–µ –æ–± –æ–ø–ª–∞—Ç–µ –µ—â–µ –Ω–µ –ø–æ—Å—Ç—É–ø–∏–ª–∏! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
            )
        }
    }

    private suspend fun confirmPayment(client: Client, messageEvent: MessageEvent?) {
        val phrase =
            if (client.trial)
                "–û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞! –°–ø–∞—Å–∏–±–æ, —á—Ç–æ —Ä–µ—à–∏–ª–∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –ø–æ –ø–æ–¥–ø–∏—Å–∫–µ."
            else
                "–û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞! –ù–∞–¥–µ—é—Å—å, –í–∞–º –ø–æ–Ω—Ä–∞–≤—è—Ç—Å—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ."
        updateClient(client)
        if (messageEvent != null)
            vKApiClient.sendMessageEventAnswer(messageEvent, getShowSnackbarString(phrase))
    }

    private suspend fun updateClient(client: Client) {
        if (client.trial) { // for clients after trial
            clientsRepository.update(
                client.id,
                newTrial = false,
                newStatus = Status.WAITING_FOR_START,
                newWeeksPassed = 0,
                newDaysPassed = 0
            )
        } else if (client.previousStatus == Status.WAITING_FOR_RESULTS && client.completedInterview()) { // for those who completed month too fast
            clientsRepository.update(
                client.id,
                newWeeksPassed = 0,
                newDaysPassed = 0
            )
            val updatedClient = clientsRepository.findById(client.id)!!
            clientsRepository.update(
                client.id,
                newStatus = Status.WAITING_FOR_START,
                newTrainingPlan = determineNextTrainingPlan(updatedClient),
                newInterviewResults = mutableListOf()
            )
        } else { // for usual clients
            clientsRepository.update(
                client.id,
                newStatus = client.previousStatus,
                newDaysPassed = 0,
                newWeeksPassed = 0
            )
        }
    }

    private fun getShowSnackbarString(text: String): String =
        """
        {
            "type": "show_snackbar", 
            "text": "$text"
        }
    """.trimIndent()

    private suspend fun sendMainKeyboardWithPromocodes(peerId: Int) {
        vKApiClient.sendMessage(
            peerId,
            "–í–ø–µ—Ä–µ–¥–∏ –º–µ—Å—è—Ü –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã—Ö —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫! –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –Ω–µ–¥–µ–ª—å–Ω—ã–π –ø–ª–∞–Ω –∏ –Ω–∞—á–∞—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å, –Ω–∞–∂–º–∏—Ç–µ \"–ù–∞—á–∞—Ç—å —Ü–∏–∫–ª\".\n" +
                    "–¢–∞–∫–∂–µ –Ω–µ –∑–∞–±—ã–≤–∞–π—Ç–µ, —á—Ç–æ –í–∞–º —Ç–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω—ã –ø—Ä–æ–º–æ–∫–æ–¥—ã üéÅ",
            keyboard = mainKeyboardWithPromocodes
        )
    }

    companion object {
        @Serializable
        private data class Event(
            val type: String,
            @SerialName("object")
            val messageEvent: MessageEvent,
            @SerialName("group_id")
            val groupId: Long
        )

        @Serializable
        data class MessageEvent(
            @SerialName("user_id")
            val userId: Int,
            @SerialName("peer_id")
            val peerId: Int,
            @SerialName("event_id")
            val eventId: String
        )
    }
}